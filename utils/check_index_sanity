#!/usr/bin/env python

# BEGIN_COPYRIGHT
# END_COPYRIGHT

import sys, os, optparse

#---------------------------------------------------------------
import logging, time
LOG_FILENAME = 'check_index_sanity.log'
logging.basicConfig(filename=LOG_FILENAME,
                    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
                    level=logging.DEBUG)

logger = logging.getLogger("check_index_sanity")

ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)

formatter = logging.Formatter()

ch.setFormatter(formatter)

logger.addHandler(ch)

counter = 0
def debug_boundary(f):
  def debug_boundary_wrapper(*args, **kv):
    global counter
    now = time.time()
    counter += 1
    logger.debug('%s[%d] in' % (f.__name__, counter))
    res = f(*args, **kv)
    logger.debug('%s[%d] out (%f)' % (f.__name__, counter,
                                      time.time() - now))
    counter -= 1
    return res
  return debug_boundary_wrapper

#---------------------------------------------------------------
from bl.vl.sample.kb     import KBError
from bl.vl.sample.kb     import KnowledgeBase as sKB
from bl.vl.individual.kb import KnowledgeBase as iKB


# FIXME it is stupid that we do not have a single knowledge base entry point.
VIRGIL_IKB_TABLES = ['Individual']
VIRGIL_SKB_TABLES = ['Study', 'Sample',
                     'BioSample', 'BloodSample', 'SerumSample', 'DNASample',
                     'DataSample', 'PlateWell',
                     'Action', 'ActionOnSample']

class Checker(object):
  def __init__(self, host, user, passwd, verbose=False):
    self.verbose = verbose
    self.host, self.user, self.passwd = host, user, passwd
    self.skb = sKB(driver='omero')(self.host, self.user, self.passwd)
    self.ikb = iKB(driver='omero')(self.host, self.user, self.passwd)
    self.logger = logger
    self.TABLES_TO_BE_CHECKED = self.skb.INDEXED_TARGET_TYPES + self.ikb.INDEXED_TARGET_TYPES
    self.skb_tables = [x for x in dir(self.skb) if hasattr(getattr(self.skb, x), 'OME_TABLE')]
    self.ikb_tables = [x for x in dir(self.ikb) if hasattr(getattr(self.ikb, x), 'OME_TABLE')]
    self.results = {}

  @debug_boundary
  def do_check_object_helper(self, o, table, o_vid_var):
    self.logger.debug('\tchecking %s[%s]' % (o.get_ome_table(), o.id))
    selector = '(%s == "%s")' % (o_vid_var, o.id)
    row = self.skb.get_table_rows(table, selector=selector)
    self.logger.debug('\t\tsel:%s -> %s' % (selector, row))
    if len(row) == 0:
      self.logger.error('%s[%s] should but it is not indexed' % (o.get_ome_table(), o.id))
      result = 'not indexed'
    elif len(row) > 1:
      self.logger.error('%s[%s] maps to multiple indexing lines' % (o.get_ome_table(), o.id))
      result = 'multiple indexes'
    else:
      self.logger.info('%s[%s] maps correctly' % (o.get_ome_table(), o.id))
      result = 'maps correctly'
    self.results[o.get_ome_table()] = result

  @debug_boundary
  def do_check_action(self, a):
    self.do_check_object_helper(a, self.skb.ACTION_TABLE, 'a_vid')

  @debug_boundary
  def do_check_target(self, t):
    self.do_check_object_helper(t, self.skb.TARGET_TABLE, 't_vid')

  @debug_boundary
  def do_check_object(self, o):
    if isinstance(o, self.skb.Action):
      self.do_check_action(o)
    else:
      self.do_check_target(o)

  @debug_boundary
  def do_check_objects(self, objs):
    for o in objs:
      self.do_check_object(o)

  @debug_boundary
  def do_check_all(self):
    tables = self.skb_tables + self.ikb_tables
    for ome_table in tables:
      self.do_check(ome_table)

  @debug_boundary
  def do_check(self, ome_table):
    self.logger.info('processing table %s' % ome_table)
    if ome_table in self.skb_tables:
      klass = getattr(self.skb, ome_table)
    elif ome_table in self.ikb_tables:
      klass = getattr(self.ikb, ome_table)
    else:
      raise ValueError('Table %s is unknown' % ome_table)
    #-
    objs = self.skb.get_all_instances(klass)
    self.logger.info('there are %d objects in omero table %s' % (len(objs), ome_table))
    if [x for x in self.TABLES_TO_BE_CHECKED if issubclass(klass, x)]:
      self.do_check_objects(objs)
    else:
      self.logger.info('%s is not indexed' % ome_table)

def do_consistency_checks(opts):
  checker = Checker(opts.host, opts.user, opts.passwd, opts.verbose)

  if opts.table:
    checker.do_check(opts.table)
  else:
    checker.do_check_all()

  print '#' * 70
  print
  print 'Result summary'
  for k in checker.results.keys():
    print '%s %s' % (k, checker.results[k])


#---------------------------------------------------------------
def make_parser():
  parser = optparse.OptionParser('%prog [OPTIONS]')
  parser.add_option(
    "-H", "--host", dest="host", metavar="HOST",
    help="Omero host",  default="localhost")
  parser.add_option(
    "-U", "--user", dest="user", metavar="USER",
    help="Omero user",  default="root")
  parser.add_option(
    "-P", "--passwd", dest="passwd", metavar="PASSWD",
    help="Omero user passwd")
  parser.add_option(
    "-t", "--table", dest="table", metavar="TABLE",
    help="Virgil table in Omero")
  parser.add_option(
    "-v", "--verbose",
    action="store_true", dest="verbose", default=False,
    help="don't print status messages to stdout")

  return parser

def main(argv):
  parser = make_parser()
  opts, args = parser.parse_args(argv)
  if not opts.passwd:
    parser.error("PASSWD should be provided")
  do_consistency_checks(opts)

if __name__ == "__main__":
    main(sys.argv)


# Local Variables: **
# mode: python **
# End: **
