* SNPMarkersSet do not have a label. This makes handling them more
  cumbersome than needed.

* The import modules have many common components that could be
  factored out. It gets particularly ugly when, in principle, an input
  file could contain multiple groups of records, e.g., data_collection
  and markers_set.

* we should probably avoid using OriginalFile in InformedConsent .. Why?

* we should add a check for label string truncation in importer
  marker_definition.

* get_table_rows should allow column selection. It is usually the case
  that hundreds of megabytes are transfered for nothing. For instance,
  to get the label -> rs_label association from marker definition we
  do not need to fetch also the marker mask.

* tools/map_gt_tech is definitely not handling memory in the best
  possible way. 

* it appears that the parameter selector in the various table methods
  should be handled with care: with order of 800,000 or-ed conditions
  it will make omero ice barf. Unclear if it is purely a buffer size
  problem or what. Current work-around is to use the whole set and do
  the selection, if needed, client side.

* actually, this whole thing of using internally vid to reference
  objects is kind of silly. We may as well use their omero_id when we
  known what they are. For instance, i_vid and a_vid in eav ehr table
  could be replaced directly with the Individual omero_id and the
  Action omero_id.

* there is an inconsistence in how we label the individual id in the
  eav ehr table (i_vid) and in the output of get_ehr_records (i_id).
  The root of all this naming problems is our using obj.id to get
  obj.ome_obj.vid I think that it would be better if we changed obj.id
  to obj.vid and get over with it.

* eav record should have slots for all basic openEHR classes, e.g.,
  DV_CODED_TEXT, DV_QUANTITY so that it will be easier to
  automatically map archetypes to eav records.

* we often do interconmnected sequences of operations, e.g.,
  add_gdo_data_object which should logically be atomic transactions
  but are not handled as such.

* once for all, we should decide what is the proper 'name' for the
  project. I guess that we could converge to virgil that provides 'bl'
  extensions to 'omero', thus 'omero-bioland' and thus 'bl' instead of 'vl' and
  mimetype 'x-vl/xxx' -> 'x-bl/xxx'

* importer is not handling error/warning messages uniformly.

* the importer modules have lots of code that can be factored out to
  core

* not all the importers provide record line information in the
  error/warn messages

* in the importers no use is done of the used_volume information.

* in importer.plate_well is assumed that the well will always contain DNA.

* PlateWell does not have row, column, but only slot. Should it really?.

* No actual tests for import corner cases and failures.

* the way wrapper is implemented, everytime one does, say

     pwell.container

  gets a new wrapper of the same ome_obj. Thus, doing
  
  pwell.container.reload()
  pwell.container.label

  will not work, since the reload is replacing the ome_obj of the
  container object that was generated in the first line, but not the
  one that it is actually contained inside pwell.
  The obvious work around is to do:

  plate = pwell.container
  plate.reload()
  plate.label
  #in fact
  assert id(plate.ome_obj) != id(pwell.container.ome_obj)

  we could fix this, but I am not sure that it is worthwhile. 

